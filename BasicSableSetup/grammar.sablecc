Package Grammar;

Helpers
	allcharacters = [0 .. 65535];
	digit = ['0' .. '9'];
	zero = '0';
	nonzero = ['1' .. '9'];
	upper = ['A' .. 'Z'] | 'Æ' | 'Ø' | 'Å';
	lower = ['a' .. 'z'] | 'æ' | 'ø' | 'å';
	letter = upper | lower;
	minus = '-';
	add = '+';
	
	singlespace = ' ';
	cr = 13;
	lf = 10;
	tabular = 9;
    newline = cr | lf | cr lf;

States
	start, normal;
	
Tokens
	whitespace = (singlespace | tabular | newline)*;
	number = zero | (nonzero digit*);
	assign = '=';
	plus = '+';
	lpar = '(';
	rpar = ')';
	{start->normal}
	begin = 'begin';
	identifier = letter;
	
Ignored Tokens
	whitespace;
	
Productions
	program = [bt]:begin? assignment+ {-> New program(bt, New assignments([assignment]))};
	assignment = identifier assign expression;
	expression {-> expression}
		= {addition} [left]:expressionterm plus [right]:expression
		  {-> New expression.addition(left.expression, plus, right.expression)}
		| {term} P.expressionterm
		  {-> expressionterm.expression}
		;
	expressionterm {-> expression}
		= {identifier} T.identifier {-> New expression.identifier(identifier)}
		| {value} number {-> New expression.value(number)}
		| {function} identifier lpar parameters rpar {-> New expression.function(identifier, lpar, parameters, rpar)}
		;
	parameters {-> parameters}
		= identifier*;

Abstract Syntax Tree
	program = begin? assignments;
	assignments = assignment+;
	assignment = identifier assign expression;
	expression
		= {addition} [left]:expression plus [right]:expression
		| {identifier} identifier
		| {function} identifier lpar parameters rpar
		| {value} number
		;
	parameters = [identifiers]:identifier*;