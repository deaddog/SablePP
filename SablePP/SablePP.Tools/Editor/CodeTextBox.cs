using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.IO;
using System.Linq;

using FastColoredTextBoxNS;
using SablePP.Tools.Error;
using SablePP.Tools.Lexing;
using SablePP.Tools.Nodes;
using SablePP.Tools.Parsing;

namespace SablePP.Tools.Editor
{
    /// <summary>
    /// A syntax highlighting textbox that uses a <see cref="ICompilerExecuter"/> to invoke compilation, validation and syntax highlighting.
    /// This class can be used without the use of the <see cref="EditorForm"/>.
    /// </summary>
    public class CodeTextBox : FastColoredTextBox
    {
        private SquigglyStyle errorStyle, warningStyle, messageStyle;
        private Style highlightstyle;
        private Dictionary<Range, string> tooltipMessages;
        private Dictionary<Range, SquigglyStyle> directDrawErrors;

        private ICompilerExecuter executer;
        private ResetableLexer lexer;
        private object lexerLock = new object();
        private bool lexerError;

        private CompileWorker compileWorker;
        private Result lastResult;
        private Token selectedToken;
        private List<Style> simpleStyles;
        private List<Style> moreStyles;

        private DeclarationLocatorCache decLocator;
        private IDeclarationRenamer decRenamer;

        /// <summary>
        /// Initializes a new instance of the <see cref="CodeTextBox"/> class.
        /// </summary>
        public CodeTextBox()
            : base()
        {
            errorStyle = new SquigglyStyle(Pens.Red);
            warningStyle = new SquigglyStyle(new Pen(Color.FromArgb(48, 150, 49)));
            messageStyle = new SquigglyStyle(Pens.DodgerBlue);
            highlightstyle = new SelectionStyle(new SolidBrush(Color.FromArgb(226, 230, 214)));
            tooltipMessages = new Dictionary<Range, string>();
            directDrawErrors = new Dictionary<Range, SquigglyStyle>();

            Styles[0] = errorStyle;
            Styles[1] = warningStyle;
            Styles[2] = messageStyle;
            Styles[3] = highlightstyle;

            this.executer = null;
            this.lexer = null;
            this.lexerError = true;

            this.compileWorker = new CompileWorker(this);
            this.selectedToken = null;
            this.lastResult = null;
            this.simpleStyles = new List<Style>();
            this.moreStyles = new List<Style>();

            this.decLocator = null;
            this.decRenamer = null;

            this.ToolTipNeeded += CodeTextBox_ToolTipNeeded;
        }

        /// <summary>
        /// Gets or sets the <see cref="ICompilerExecuter"/> used by this <see cref="CodeTextBox"/>.
        /// </summary>
        [Browsable(false), DefaultValue(null)]
        public ICompilerExecuter Executer
        {
            get { return executer; }
            set
            {
                executer = value;
                this.OnTextChangedDelayed(this.Range);

                if (executer == null)
                {
                    this.Range.ClearStyle(simpleStyles.ToArray());
                    this.Range.ClearStyle(moreStyles.ToArray());
                    this.Range.ClearStyle(errorStyle);
                    this.Range.ClearStyle(warningStyle);
                    this.Range.ClearStyle(messageStyle);
                }
            }
        }

        /// <summary>
        /// Gets the last compilation <see cref="Result"/> generated by the <see cref="ICompilerExecuter"/>.
        /// Consider using the <see cref="WaitForResult"/> method if the most resent result is required.
        /// </summary>
        [Browsable(false)]
        public Result LastResult
        {
            get { return lastResult; }
        }

        /// <summary>
        /// Waits for the current compilation process to finish and returns its <see cref="Result"/>.
        /// </summary>
        /// <returns>A <see cref="Result"/> detailing the result of the currently executing compilation process.</returns>
        public Result WaitForResult()
        {
            Result result = null;

            compileWorker.WaitForCompletion();

            result = this.lastResult;

            return result;
        }

        /// <summary>
        /// Gets the <see cref="Token"/> currently selected by the user.
        /// </summary>
        [Browsable(false)]
        public Token SelectedToken
        {
            get { return selectedToken; }
        }

        public IDeclarationLocator DeclarationLocator
        {
            get
            {
                if (decLocator == null)
                    return null;
                else
                    return decLocator.Inner;
            }
            set
            {
                if (value == null)
                    decLocator = null;
                else
                    decLocator = new DeclarationLocatorCache(value);
            }
        }
        public IDeclarationRenamer DeclarationRenamer
        {
            get { return decRenamer; }
            set { decRenamer = value; }
        }

        public void GoToDeclaration()
        {
            if (selectedToken == null)
                throw new InvalidOperationException("No token is selected.");
            else
                GoToDeclaration(selectedToken);
        }
        public void GoToDeclaration(Token token)
        {
            if (decLocator == null)
                throw new InvalidOperationException("GoToDeclaration is not available when property DeclarationLocator is not set.");
            if (token == null)
                throw new ArgumentNullException("token");

            Token declaration = decLocator.FindDeclaration(token);
            if (declaration != null)
            {
                var range = RangeFromToken(declaration);
                Selection = range;
                DoRangeVisible(range, true);
            }
        }
        public bool HasDeclaration()
        {
            return HasDeclaration(selectedToken);
        }
        public bool HasDeclaration(Token token)
        {
            if (decLocator == null)
                return false;

            if (token == null)
                return false;

            return decLocator.FindDeclaration(token) != null;
        }

        public void RenameDeclaration(string newName = null)
        {
            if (selectedToken != null)
                RenameDeclaration(selectedToken, newName);
        }
        public void RenameDeclaration(Token token, string newName = null)
        {
            if (decRenamer == null)
                throw new InvalidOperationException("RenameDeclaration is not available when property DeclarationRenamer is not set.");
            if (decLocator == null)
                throw new InvalidOperationException("RenameDeclaration is not available when property DeclarationLocator is not set.");
            if (token == null)
                throw new ArgumentNullException("token");

            if (newName == null)
                newName = RenameForm.ShowDialog(decRenamer, token);
            if (newName == null)
                return;

            var dec = decLocator.FindDeclaration(token);

            var renamees = decRenamer.FindRenamees(dec, lastResult).Select(x =>
            {
                var r = RangeFromToken(x);
                return Tuple.Create(PlaceToPosition(r.Start), PlaceToPosition(r.End));
            }).ToArray();
            Array.Sort(renamees, (x, y) => -x.Item1.CompareTo(y.Item1));

            int oldPosition = PlaceToPosition(RangeFromToken(dec).Start);
            int newPosition = oldPosition;
            int offset = newName.Length - token.Text.Length;

            string text = Text;
            for (int i = 0; i < renamees.Length; i++)
            {
                text = text.Substring(0, renamees[i].Item1) + newName + text.Substring(renamees[i].Item2);
                if (renamees[i].Item1 < oldPosition && renamees[i].Item2 < oldPosition)
                    newPosition += offset;
            }
            Text = text;
            this.Selection = new Range(this, PositionToPlace(newPosition), PositionToPlace(newPosition));
            Range.ClearStyle(highlightstyle);
            this.DoCaretVisible();
        }

        /// <summary>
        /// Occurs when the <see cref="ICompilerExecuter"/> associated with this <see cref="CodeTextBox"/> is done compiling an AST.
        /// The event is raised regardless of the result of the compilation.
        /// The event is never raised when the <see cref="CodeTextBox"/> is not associated with an <see cref="ICompilerExecuter"/>.
        /// </summary>
        public event EventHandler CompilationCompleted;

        private void setStyle(Token token, Style style)
        {
            if ((from s in Styles where s != null select s).Count() >= 16 && !Styles.Contains(style))
                this.ClearStylesBuffer();
            RangeFromToken(token).SetStyle(style);
        }

        /// <summary>
        /// Gets the <see cref="Range"/> in this <see cref="CodeTextBox"/> of a <see cref="Token"/>.
        /// </summary>
        /// <param name="token">The <see cref="Token"/> from which <see cref="Range"/> should be retrieved.</param>
        /// <returns>A <see cref="Range"/> representing the location of <paramref name="token"/> in this <see cref="CodeTextBox"/>.</returns>
        public Range RangeFromToken(Token token)
        {
            string text = token.Text;

            Place p1 = new Place(token.Position - 1, token.Line - 1);
            Place p2 = new Place(token.Position - 1, token.Line - 1);

            int len = text.Length;
            while (text.Contains('\r'))
            {
                int index = text.IndexOf('\r');
                len -= index + 2;
                text = text.Substring(index + 2);

                p2.iLine++;
                p2.iChar = 0;
            }
            p2.iChar += len;
            return new Range(this, p1, p2);
        }
        /// <summary>
        /// Gets the <see cref="Range"/> in this <see cref="CodeTextBox"/> of a <see cref="Production"/>.
        /// </summary>
        /// <param name="production">The <see cref="Production"/> from which <see cref="Range"/> should be retrieved.</param>
        /// <returns>A <see cref="Range"/> containing all the tokens of <paramref name="production"/>.</returns>
        public Range RangeFromProduction(Production production)
        {
            var first = RangeFromToken(Tools.Analysis.DepthFirstTreeWalker.GetTokens(production).First());
            var last = RangeFromToken(SablePP.Tools.Analysis.DepthFirstReversedTreeWalker.GetTokens(production).First());
            return first.GetUnionWith(last);
        }
        /// <summary>
        /// Gets the <see cref="Range"/> in this <see cref="CodeTextBox"/> of a <see cref="Node"/> by invoking <see cref="RangeFromToken"/> or <see cref="RangeFromProduction"/>.
        /// </summary>
        /// <param name="node">The <see cref="Node"/> from which <see cref="Range"/> should be retrieved.</param>
        /// <returns>A <see cref="Range"/> containing all the tokens of <paramref name="node"/> (or just the single element if <paramref name="node"/> is a <see cref="Token"/>).</returns>
        public Range RangeFromNode(Node node)
        {
            if (node is Token)
                return RangeFromToken(node as Token);
            else if (node is Production)
                return RangeFromProduction(node as Production);
            else
                throw new ArgumentException("Range can only be retrieved from tokens and productions.", "node");
        }
        /// <summary>
        /// Gets the <see cref="Token"/> located at <paramref name="place"/> in this <see cref="CodeTextBox"/>.
        /// Tokens are found in the <see cref="LastResult"/> property.
        /// </summary>
        /// <param name="place">The place to look for a <see cref="Token"/>.</param>
        /// <returns>The <see cref="Token"/> located at <paramref name="place"/>, if any; otherwise <c>null</c>.</returns>
        public Token TokenFromPlace(Place place)
        {
            Result res = lastResult;
            if (res == null || res.Tree == null)
                return null;

            foreach (var token in SablePP.Tools.Analysis.DepthFirstTreeWalker.GetTokens(res.Tree))
                if (RangeFromToken(token).Contains(place))
                    return token;
            return null;
        }
        /// <summary>
        /// Get the <see cref="Token"/> containing <paramref name="range"/> in this <see cref="CodeTextBox"/>.
        /// Tokens are found in the <see cref="LastResult"/> property.
        /// </summary>
        /// <param name="range">The range in which to look for a <see cref="Token"/>.</param>
        /// <returns>The <see cref="Token"/> containing <paramref name="range"/>, if any exists; otherwise <c>null</c>.
        /// If <paramref name="range"/> is larger than any 'close' <see cref="Token"/>, <c>null</c> is returned.</returns>
        public Token TokenFromRange(Range range)
        {
            if (range.Start != range.End)
            {
                var s = TokenFromPlace(range.Start);
                var e = TokenFromPlace(range.End);

                return s == e ? s : null;
            }
            else
                return TokenFromPlace(range.Start);
        }

        private SquigglyStyle getSquigglyStyle(ErrorType errorType)
        {
            switch (errorType)
            {
                case ErrorType.Error: return errorStyle;
                case ErrorType.Warning: return warningStyle;
                case ErrorType.Message: return messageStyle;
                default: throw new ArgumentException("Unknown error type.");
            }
        }

        private void addError(CompilerError error)
        {
            Range range = new Range(this,
                error.Start.Character - 1, error.Start.Line - 1,
                error.End.Character, error.End.Line - 1);

            if (!(range.Start.iChar < 1 && range.Start.iLine < 1 && range.End.iChar < 1 && range.End.iLine < 1))
            {
                var style = getSquigglyStyle(error.ErrorType);
                if (range.GetIntersectionWith(this.Range).IsEmpty)
                    directDrawErrors.Add(range, style);
                else
                    range.SetStyle(style);
                tooltipMessages.Add(range, error.ErrorMessage);
            }

            if (ErrorAdded != null)
                ErrorAdded(this, new ErrorEventArgs(error));
        }
        private void clearErrors()
        {
            directDrawErrors.Clear();
            this.Range.ClearStyle(errorStyle, warningStyle, messageStyle);
            this.tooltipMessages.Clear();

            if (ErrorsCleared != null)
                ErrorsCleared(this, EventArgs.Empty);
        }

        /// <summary>
        /// Occurs when all the errors in the <see cref="CodeTextBox"/> are removed.
        /// </summary>
        public event EventHandler ErrorsCleared;
        /// <summary>
        /// Occurs when a new <see cref="CompilerError"/> is added to the <see cref="CodeTextBox"/>.
        /// </summary>
        public event EventHandler<ErrorEventArgs> ErrorAdded;

        private bool useSmartPar = true;
        /// <summary>
        /// Gets or sets a value indicating whether the <see cref="CodeTextBox"/> should use smart parenthesis (inserting of '(' when text is selected will enclose the text with '(...)'.
        /// </summary>
        [DefaultValue(true)]
        public bool UseSmartParenthesis
        {
            get { return useSmartPar; }
            set { this.useSmartPar = value; }
        }

        private bool isParenthesisStart(char? c)
        {
            if (!c.HasValue)
                return false;

            switch (c.Value)
            {
                case '(':
                case '{':
                case '[':
                case '<':
                    return true;
                default:
                    return false;
            }
        }
        private bool isParenthesisEnd(char? c)
        {
            if (!c.HasValue)
                return false;

            switch (c.Value)
            {
                case ')':
                case '}':
                case ']':
                case '>':
                    return true;
                default:
                    return false;
            }
        }
        private char? getParenthesisEnd(char? start)
        {
            if (!start.HasValue)
                return null;

            switch (start.Value)
            {
                case '(': return ')';
                case '{': return '}';
                case '[': return ']';
                case '<': return '>';
                default: return null;
            }
        }
        private bool handleSmartParenthesis(char c)
        {
            char? nextChar = Text.Length > SelectionStart ? (char?)Text[SelectionStart] : null;

            if (isParenthesisStart(c))
            {
                if (SelectionLength == 0 && nextChar.HasValue && !char.IsWhiteSpace(nextChar.Value) && nextChar != getParenthesisEnd(c))
                    return false;

                int s = SelectionStart;
                int l = SelectionLength;
                this.InsertText(c + this.Text.Substring(s, l) + getParenthesisEnd(c).Value);
                this.SelectionStart = s + 1;
                this.SelectionLength = l;
                return true;
            }
            else if (isParenthesisEnd(c))
            {
                if (this.SelectionLength > 0)
                    return false;

                if (nextChar == c)
                {
                    this.SelectionStart++;
                    return true;
                }
            }

            return false;
        }

#pragma warning disable 1591
        protected sealed override void OnEnabledChanged(EventArgs e)
        {
            if (!this.Enabled)
                this.clearErrors();
            base.OnEnabledChanged(e);
        }

        public sealed override bool ProcessKey(char c, System.Windows.Forms.Keys modifiers)
        {
            if (useSmartPar && handleSmartParenthesis(c))
                return true;
            else
                return base.ProcessKey(c, modifiers);
        }

        public sealed override void OnTextChangedDelayed(Range changedRange)
        {
            if (executer != null && this.Enabled)
                lock (lexerLock)
                {
                    StringReader reader = new StringReader(this.Text);
                    lexer = new ResetableLexer(executer.GetLexer(reader));

                    lexerError = false;
                    try { while (!(lexer.Next() is EOF)) { } }
                    catch (LexerException) { lexerError = true; }
                    lexer.Reset();
                    reader.Dispose();

                    if (lexerError)
                        changedRange.ClearStyle(simpleStyles.ToArray());
                    else
                    {
                        this.Range.ClearStyle(simpleStyles.ToArray());
                        while (!(lexer.Peek() is EOF))
                        {
                            Token token = lexer.Next();
                            Style style = executer.GetSimpleStyle(token);
                            if (style != null)
                            {
                                if (!simpleStyles.Contains(style))
                                    simpleStyles.Add(style);
                                this.setStyle(token, style);
                            }
                        }
                    }
                    lexer.Reset();
                    compileWorker.Start(executer, lexer);
                }

            base.OnTextChangedDelayed(changedRange);
        }

        public override void OnSelectionChanged()
        {
            this.selectedToken = TokenFromRange(this.Selection);

            Range.ClearStyle(highlightstyle);
            if (this.decLocator != null && this.selectedToken != null)
            {
                var dec = decLocator.FindDeclaration(selectedToken);

                foreach (var token in decLocator.FindReferences(dec, lastResult))
                {
                    var r = RangeFromToken(token);
                    if (Range.Contains(r.Start) && (Range.Contains(r.End)))
                        r.SetStyle(highlightstyle);
                }

            }

            base.OnSelectionChanged();
        }

        protected sealed override void OnPaint(System.Windows.Forms.PaintEventArgs e)
        {
            base.OnPaint(e);
            foreach (var r in directDrawErrors)
                r.Value.Draw(e.Graphics, PlaceToPoint(r.Key.Start), r.Key);
        }
#pragma warning restore

        void CodeTextBox_ToolTipNeeded(object sender, ToolTipNeededEventArgs e)
        {
            foreach (var r in tooltipMessages.Keys)
                if (r.Contains(e.Place))
                {
                    e.ToolTipText = tooltipMessages[r];
                    break;
                }
        }

        private class CompileWorker : BackgroundWorker
        {
            private CodeTextBox parent;
            private ICompilerExecuter executer;
            private ILexer lexer;
            private ICompilerExecuter nextExecuter;
            private ILexer nextLexer;

            private bool shouldStart;
            private bool waitFlag = false;

            public CompileWorker(CodeTextBox parent)
            {
                this.parent = parent;
                this.executer = null;
                this.lexer = null;
                this.shouldStart = false;
            }

            public void Start(ICompilerExecuter executer, ILexer lexer)
            {
                this.nextExecuter = executer;
                this.nextLexer = lexer;

                this.shouldStart = true;

                if (!this.IsBusy)
                {
                    this.lexer = nextLexer;
                    this.executer = nextExecuter;

                    shouldStart = false;
                    RunWorkerAsync();
                }
            }
            private void restart()
            {
                if (!this.IsBusy)
                {
                    this.lexer = nextLexer;
                    this.executer = nextExecuter;

                    shouldStart = false;
                    RunWorkerAsync();
                }
            }

            protected override void OnDoWork(DoWorkEventArgs e)
            {
                waitFlag = true;
                IParser parser = executer.GetParser(lexer);
                ErrorManager errorManager = new ErrorManager();

                Node root;
                try { root = parser.Parse(); }
                catch (LexerException ex)
                {
                    errorManager.Register(ex);
                    root = null;
                }
                catch (ParserException ex)
                {
                    errorManager.Register(ex);
                    root = null;
                }

                CompilationOptions compilationOptions = new CompilationOptions(parent.Text, errorManager, (highlight) =>
                    {
                        if (ReferenceEquals(highlight, null))
                            throw new ArgumentNullException("highlight");

                        if (parent != null)
                        {
                            HighlightWalker walker = new HighlightWalker(parent, highlight);
                            walker.Visit(root);
                        }
                    });

                if (root != null)
                {
                    parent.Range.ClearStyle(parent.moreStyles.ToArray());
                    parent.moreStyles.Clear();

                    compilationOptions.active = true;
                    executer.Validate(root, compilationOptions);
                    compilationOptions.active = false;
                }

                e.Result = storeRootAndErrors(root, errorManager);
            }
            protected override void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e)
            {
                Node node;
                CompilerError[] errors;

                if (loadRootAndErrors(e.Result, out node, out errors))
                {
                    parent.clearErrors();
                    foreach (var err in errors)
                        parent.addError(err);
                }

                parent.lastResult = new Result(node, errors);
                parent.OnSelectionChanged();

                if (parent.CompilationCompleted != null)
                    parent.CompilationCompleted(parent, EventArgs.Empty);

                waitFlag = false;

                if (shouldStart)
                    restart();
            }

            public void WaitForCompletion()
            {
                bool waitAgain = false;
                while (waitFlag) { }
                while (shouldStart) { waitAgain = true; }

                if (waitAgain)
                    while (waitFlag) { }

                if (parent.lastResult == null)
                {
                    while (!IsBusy) { }
                    WaitForCompletion();
                }
            }

            private object storeRootAndErrors(Node root, IEnumerable<CompilerError> errors)
            {
                return new { Root = root, Errors = errors.ToArray() };
            }
            private bool loadRootAndErrors(object arg, out Node root, out CompilerError[] errors)
            {
                if (arg == null)
                {
                    root = null;
                    errors = null;
                    return false;
                }

                dynamic loaded = arg;
                root = loaded.Root;
                errors = loaded.Errors;

                return true;
            }

            private class HighlightWalker : SablePP.Tools.Analysis.DepthFirstTreeWalker
            {
                private CodeTextBox parent;
                private IHighlighter highlighter;
                public HighlightWalker(CodeTextBox parent, IHighlighter highlighter)
                {
                    this.parent = parent;
                    this.highlighter = highlighter;
                }

                public override void Visit(Token token)
                {
                    var s = highlighter.GetStyle(token);
                    if (s != null)
                    {
                        if (!parent.moreStyles.Contains(s))
                            parent.moreStyles.Add(s);
                        parent.setStyle(token, s);
                    }
                }
            }
        }

        /// <summary>
        /// Represents a completed compilation attempt.
        /// </summary>
        public class Result
        {
            private DateTime time;
            private Node root;
            private CompilerError[] errors;

            internal Result(Node tree, IEnumerable<CompilerError> errors)
            {
                this.time = DateTime.Now;

                this.root = tree;
                this.errors = errors.ToArray();
            }

            /// <summary>
            /// Gets the <see cref="DateTime"/> the compilation was completed.
            /// </summary>
            public DateTime CompileTime
            {
                get { return time; }
            }
            /// <summary>
            /// Gets the root of the generated AST. If the lexer or parser failed this value is <c>null</c>.
            /// </summary>
            public Node Tree
            {
                get { return root; }
            }
            /// <summary>
            /// Gets the errors registered in validation of the code.
            /// </summary>
            public CompilerError[] Errors
            {
                get { return errors; }
            }
        }
    }
}
